#include <utility>
#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <list>

#include "pin.H"

using namespace std;
ofstream RtnOut("crypto.out", ofstream::out);

// This struct is used to record informations of the application's routines
typedef struct RtnInfo
{
	string _name;	// routine's name
	string _image;	// image the routine loaded from
	ADDRINT _address;	// routine's entyr address
	RTN _rtn;		// Pin object of the routine
	UINT64 _rtnCount;	// the number of the routines in the app
	//UINT64 _iCount;		// the number of instructions in the routine
} RTN_INFO;

list<RTN_INFO> RtnList;

// Count instructions or routines
VOID PIN_FAST_ANALYSIS_CALL docount(UINT64 * counter)
{
	(*counter)++;
}

// Strip image path and return image name
const char * StripPath(const char * path)
{
	const char * name = strrchr(path, '\\');
	if (name)
		return name + 1;
	else
		return path;
}

VOID ImageLoad(IMG img, VOID *v)
{

	// When a image is loaded, find all routines in it
	for (SEC sec = IMG_SecHead(img); SEC_Valid(sec); sec = SEC_Next(sec))
	{
		for (RTN rtn = SEC_RtnHead(sec); RTN_Valid(rtn); rtn = RTN_Next(rtn))
		{
			// Initialize rtn info struct
			RTN_INFO *ri = new RTN_INFO;

			// the RTN goes away when the image is unloaded, so save it when it is called
			// Static routine infos, the routine may not be executed in runtime
			ri->_name = RTN_Name(rtn);
			ri->_image = StripPath(IMG_Name(img).c_str());
			ri->_address = RTN_Address(rtn);
			//ri->_iCount = 0;
			ri->_rtnCount = 0;

			RtnList.push_back((*ri));		// Put the routine node in the list

			RTN_Open(rtn);

			if (!RTN_IsArtificial(rtn) && !RTN_IsDynamic(rtn)) // If the rtn is not generated by pin
			{
				// Insert a call at the entry point of a routine to increment the call count
				RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)docount, IARG_FAST_ANALYSIS_CALL, IARG_PTR, &(RtnList.back()._rtnCount), IARG_END);
			}

			RTN_Close(rtn);

		}
	}
}

VOID OutputRtnInfo()
{
	SetAddress0x(true);

	// Dump routine infos of the application
	RtnOut << left << setw(30) << "Procedure" << "  "
		<< setw(25) << "Image" << "  "
		<< setw(18) << "Address" << "  "
		<< setw(12) << "Calls" << "  "
		<< setw(12) << "InsCount" << endl;
	for (list<RTN_INFO>::iterator ri = RtnList.begin(); ri != RtnList.end(); ri++)
	{
		if (ri->_rtnCount > 0) // Ensure the routine is not empty and executed in runtime  ri->_rtnCount > 0
		{
			RtnOut << left << setw(30) << ri->_name << "  "
				<< setw(25) << ri->_image << "  "
				<< setw(18) << StringFromAddrint(ri->_address) << "  "
				<< setw(12) << ri->_rtnCount << endl;

		}
	}

	RtnList.clear();
	if (RtnOut.is_open()) RtnOut.close();

}

// This function is called when the application exits
VOID Fini(INT32 code, VOID *v)
{
	OutputRtnInfo();

	cout << "\n***************** application exited! *******************" << endl;

}
/* ===================================================================== */
/* Print Help Message                                                    */
/* ===================================================================== */

INT32 Usage()
{
	cerr << "This tool counts the number of dynamic instructions executed" << endl;
	cerr << endl << KNOB_BASE::StringKnobSummary() << endl;
	return -1;
}

/* ===================================================================== */
/* Main                                                                  */
/* ===================================================================== */
/*   argc, argv are the entire command line: pin -t <toolname> -- ...    */
/* ===================================================================== */
int main(int argc, char * argv[])
{
	// Initialize symbol table code, needed for rtn instrumentation
	//PIN_InitSymbolsAlt(EXPORT_SYMBOLS);
	PIN_InitSymbols();

	// Initialize pin
	if (PIN_Init(argc, argv)) return Usage();

	// Register ImageLoad to be called to instrument image
	IMG_AddInstrumentFunction(ImageLoad, 0);

	// Register Fini to be called when the application exits
	PIN_AddFiniFunction(Fini, 0);

	// Start the program, never returns
	PIN_StartProgram();

	cout << "\n********************** Instrumention complete! *******************" << endl;

	return 0;
}